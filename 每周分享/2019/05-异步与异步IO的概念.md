---
title: "异步与异步I/O的概念"
date: "2019-07-18"
permalink: "2019-07-18-async"
---

# 背景

在之前读[《Unix环境高级编程》](https://book.douban.com/subject/25900403/)这本书的时候，了解到unix下使用异步IO是很困难的事情。但是遇到了下面两件事情让我对**异步I/O**这个概念产生困惑：

1. node声称是异步I/O（使用了libuv），经过查阅资料了解到，其中所谓的“异步I/O”内部使用的是I/O多路复用实现的，根据POSIX标准，select/poll/epoll等I/O多路复用函数仍然在同步IO范围内。这就引起了一个问题：**I/O多路复用是异步I/O吗？**

1. 最近听了框架分享会，声称是具有异步I/O；一些go的用户也将gorotinue与异步I/O混为一谈。其中这两个都是使用协程来实现的，这是又有一个疑惑：**协程是异步I/O吗？**



#POSIX 的同步I/O和异步I/O

## I/O的分类

我对I/O的理解来自《Unix环境高级编程》这本书，其中介绍了POSIX的异步I/O标准，在wiki上对应 [Asynchronous I/O](https://en.wikipedia.org/wiki/Asynchronous_I/O)。根据标准同步I/O和异步I/O的分类如下（来自wiki）


![p6bbiOFW64a6zzyxueD5j646YEJuqrA3IFcHNrYVVUIINJmNCV.png](https://i.loli.net/2019/07/18/5d308f7c8530d99874.png)

**（根据标准：异步阻塞是不存在的）**



## 五个I/O模型

不管什么I/O模型，总体的I/O过程都是一致的

- 发起系统调用（例如read或者write函数）

- 等待数据到来（可以是阻塞也可以是非阻塞）

- 将数据从内核空间拷贝到用户空间（可以是阻塞也可以是非阻塞）

- 返回数据

（图来自[《Unix网络编程》](https://book.douban.com/subject/1500149/)）

### 阻塞I/O模型

对应到同步阻塞I/O

![ejpOroyQ4VEfg14DZRgbPYv2KsAKBJcPOSXgO91e6hDTeQfxrM.png](https://i.loli.net/2019/07/18/5d308f9d1d21334377.png)



### 非阻塞I/O模型

对应到同步非阻塞。使用轮询查看一个文件是否就绪，如果就绪则进行拷贝，否则返回-1（read/write函数来说如果fd未就绪则返回-1）



![jdtuQ4d6A0CswcXCMbr3M1gbrSzcHHSBMrmSeGGfJVDVWZ4II7.png](https://i.loli.net/2019/07/18/5d308f9e8188772425.png)



### I/O多路复用模型

I/O多路复用一次可以观察多个文件是否就绪，某一个或多个就绪则返回，然后用户主动调用read/write函数将数据拷贝到用户空间（**这个过程是阻塞的）**

![NQECSx93llYNiIJ7GzLI18EKZOs00OiMzT6TjN9FTcif621ceK.png](https://i.loli.net/2019/07/18/5d308f9e445ae35644.png)

熟悉java的同学应该了解java nio，这里的nio指的就是I/O多路复用。



### 信号驱动

使用linux中的信号机制实现的I/O模型，似乎用的比较少，这里不讨论



### 异步I/O模型

发送system call，这里的通常使用aio_read/aio_write函数，以aio_read为例，调用该函数需要指定文件描述符，缓冲区，以及缓冲区大小，缓冲区偏移量，I/O完成的回掉函数等字段，发起aio_read后立即返回，此后**用户不需要主动将数据从内核区拷贝到用户区，系统会帮忙完成这个工作，拷贝完成后如果有注册回掉函数，会调用回掉函数。**

![7xxbLtGwXTdU4sfKJg30k2BZVx0A3WRLEgmFcVARko93zDmtlk.png](https://i.loli.net/2019/07/18/5d308f996d40777949.png)

## 如何区分是同步IO还是异步IO呢？

我认为关键在于：**数据从内核空间拷贝到用户空间这个过程是否会阻塞用户线程，在异步I/O中用户不需要手动去read/write来拷贝数据，而同步I/O中用户需要手动拷贝。**



异步I/O的定义（来自wiki）：**asynchronous I/O (also non-sequential I/O) is a form of input/output processing that permits other processing to continue before the transmission has finished.**

（我的理解：调用I/O函数后，异步I/O允许当前线程继续执行其他函数或过程，而同步I/O不允许，因为即使是使用I/O多路复用，也需要调用select/poll/epoll_wait 等函数，会阻塞当前线程）



https://zhuanlan.zhihu.com/p/36344554

**同步IO的特点：**

> 同步IO指的是用户进程触发I/O操作并等待或者轮询的去查看I/O操作是否就绪。
同步IO的执行者是IO操作的发起者。
同步IO需要发起者**进行内核态到用户态的数据拷贝过程**，所以这里必须阻塞

**异步IO的特点：**

> 异步IO是指用户进程触发I/O操作以后就立即返回，继续开始做自己的事情，而当I/O操作已经完成的时候会得到I/O完成的通知。
异步IO的执行者是内核线程，**内核线程将数据从内核态拷贝到用户态**，所以这里没阻塞



## 附

知乎的一个大牛有下面的言论（最近在研究他的《Linux 多线程服务端编程：使用 muduo C++ 网络库》这本书）

![lOASx0HtH4jFnXdGdMiXGqfQhdXXCqJbgjcpu1x88OYjvcBOmT.png](https://i.loli.net/2019/07/18/5d308fa195c7663416.png)


原因在于Linux的aio函数太难以使用，node.js中的“异步I/O”也是同步I/O来实现的。

# 异步

通常大家在讨论的异步I/O，并不是POSIX中的异步I/O，对应到维基百科中的[Asynchrony (computer programming)](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))  （所以各种博客上讨论的异步I/O我觉得应该称为异步，不要带上I/O）

wiki认为：**Asynchrony refers to the occurrence of events independent of the main program flow and ways to deal with such events.** 

异步是指代一个事件的发生是独立于程序流的。在以往的同步代码中，程序是一句一句往下执行的，而在异步代码中，程序可能并不是顺序执行。



- 异步要解决什么？

我的理解是：我们发起函数调用经常会涉及到I/O操作，而这些I/O操作经常会将阻塞当前线程，线程会被挂起（CPU空闲下来），而这个时间该线程在I/O完成之前完全可以做其他事情。为了解决这个问题，充分利用CPU，通常会有两种解决方案：**事件驱动和协程**。

## 事件驱动

### 介绍

事件驱动通常会开启一个或多个专门处理I/O请求的线程，每当主线程有I/O事件发生，就将该I/O请求包装好放到事件队列中，主线程不自己做I/O请求，在I/O完成后事件循环会将结果返回给主线程供回调。

 

常见的事件处理模型有 Reactor和Proactor （reactor模型是同步I/O模型，Proactor是异步I/O模型，常见的libevent node 都是reactor模型，暂时还没见过有使用Proactor模型的开源软件）

下图来自[《linux高性能服务端编程》](https://book.douban.com/subject/24722611/)

![lyt6aFQOAbewXGi6FhE1o8L404V07qld26MoEWR2sj2teD8bt3.png](https://i.loli.net/2019/07/18/5d308fa15cc6a28593.png)





### 为什么说JavaScript是单线程的？那么如何实现异步呢？

单线程是针对JavaScript程序员而言，而不是针对javascript引擎的开发人员而言（例如V8的开发者）。以node.js为例子，启动node后不止一个线程（在我的机器上是7个线程）

![v8RDt6eTMBls3eLT1EhYSg9FWQ3d0WDXR7Z2RaBwZjQYuC70XK.png](https://i.loli.net/2019/07/18/5d30905961d6148066.png)



其中一个是主线程，其他都是I/O线程。

主线程发起异步调用后（例如setTimeout或者readFile)，会把请求丢给event loop处理，这个event loop（libuv）底层通常是epoll实现，对于就绪的事件会丢给线程池，让IO线程执行真正的I/O读写，读写完成后将结果返回给主线程，然后主线程在执行回掉函数。我们认为node.js是单线程的，指的是只有一个主线程，但是node.js有多个I/O线程。

![A8yGBTuzwlYjJvYT8wRHwvQfyLgko61ACy850fDJIWI4SjaBWa.png](https://i.loli.net/2019/07/18/5d308f9a4d52713817.png)

关于event loop，可以看下这个视频 [Help I'm stuck in an event loop](https://v.youku.com/v_show/id_XMjY5MTkwMDYzNg====.html?refer=seo_operation.liuxiao.liux_00003303_3000_Qzu6ve_19042900)

![yNl8vCwZa38DqFJWFxQEOA8cfLEitlpIiZ2dujz0ZBxQNDpTZw.png](https://i.loli.net/2019/07/18/5d3090599cd3995074.png)



### 例子

使用epoll的时候， 你在后台有一个线程在做事件循环， 你的业务逻辑在自己的线程里面注册了一些事件的回调（对某个文件描述符上的特定事件感兴趣），你的业务逻辑继续自己的流程，当事件发生的时候，事件的处理在事件循环线程进行，独立于你的业务逻辑在的线程。（符合异步的定义，事件的处理独立于控制流）

而且需要注意，为什么epoll这种用法是不符合异步I/O的定义的，因为你注册的是对某些事件的回调，并没有发起任何IO请求（read/write），你是在事件发生后，在事件处理函数里面才发起的I/O请求，而因为事件已经发生了，所以这时候发起的慢速系统调用可以马上完成，也就不会把事件循环线程给堵住了。

（来自 https://www.zhihu.com/question/59975081/answer/171043381）



## 协程

协程是用户态执行单元，它的创建，执行，上下文切换，挂起，销毁都是在用户态中完成，可以看成是一个轻量的线程，只不过线程是OS进行切换的。一个线程中可以包含很多个协程。

显然协程不适合计算密集型的任务，而适合I/O密集型的任务。（因为I/O密集型任务CPU利用率通常比较低，I/O操作会使线程进入阻塞状态，如果“预感”到要进入阻塞态就进行切换去处理其他协程，等下一次调度在继续执行，这样做能提高CPU的利用率）



关于协程切换会涉及到的问题

### 如何进行切换？

保存用户栈和寄存器，然后用一条long jump指令跳转到其他地方执行代码。

这里可以阅读腾讯微信的协程库[libco](https://github.com/Tencent/libco)（代码不长，有时间我一定仔细研究。。） 里面关于用户栈切换的[关键代码![img]![B5NJX6wag8PSMpJiiqy6gfHdFDUD2ROD9zNbH48Spu3GQwvlwQ.png](https://i.loli.net/2019/07/18/5d308fa05cb4193499.png)

### 何时切换

- 遇到I/O操作或者sleep。在python或者JavaScript中又yield关键字，可以用这个关键字实现上下文的切换。

- 关于gevent库，其中需要用到monkey patch，应该是将python中的I/O相关函数都hook下来，然后调用I/O函数之前会先执行yield操作。（这个patch做法个人感觉不太稳妥）



关于协程，后面会花更多时间研究，关于python的yield和asyncio库，go的gorotinue相关。。







